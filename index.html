<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Picross OCR (TFJS + Tesseract fallback)</title>
<style>
  body{font-family:system-ui; padding:10px;}
  #preview{max-width:420px; display:block; margin-bottom:8px;}
  .thumb{display:inline-block; margin:4px; text-align:center;}
  .thumb canvas{width:56px; height:56px; border:1px solid #ccc; image-rendering:pixelated;}
  #log{white-space:pre-wrap; background:#f4f4f4; padding:8px; max-height:200px; overflow:auto;}
  button{margin-left:8px;}
</style>
</head>
<body>
<h3>Picross OCR —推論</h3>
<input type="file" id="fileInput" accept="image/*">
<button id="runBtn">抽出・OCR 実行</button>
<div id="status"></div>
<img id="preview" alt="preview">
<div id="log">ログ:</div>

<div>
  <h4>上側ヒント</h4>
  <div id="topHints"></div>
</div>
<div>
  <h4>左側ヒント</h4>
  <div id="leftHints"></div>
</div>

<!-- OpenCV (non-async recommended) -->
<script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
<!-- Tesseract fallback -->
<script src="https://unpkg.com/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<!-- TensorFlow.js (used only if model present) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>

<script>
const fileInput = document.getElementById('fileInput');
const runBtn = document.getElementById('runBtn');
const preview = document.getElementById('preview');
const logEl = document.getElementById('log');
const topHintsEl = document.getElementById('topHints');
const leftHintsEl = document.getElementById('leftHints');
const statusEl = document.getElementById('status');

let loadedImage = null;
let cvReady = false;
cv['onRuntimeInitialized'] = () => { cvReady = true; appendLog('✔ OpenCV ready'); };

function appendLog(s){ logEl.textContent += '\n' + s; logEl.scrollTop = logEl.scrollHeight; }

fileInput.onchange = e => {
  const f = e.target.files[0];
  if(!f) return;
  preview.onload = () => { preview.width = preview.naturalWidth; preview.height = preview.naturalHeight; loadedImage = f; appendLog(`Preview loaded ${preview.naturalWidth}x${preview.naturalHeight}`); };
  preview.src = URL.createObjectURL(f);
};

async function loadTFModelIfPresent(){
  // model path inside repo for GitHub Pages: ./models/mnist_custom/model.json
  try {
    const url = './models/mnist_custom/model.json';
    appendLog('Trying to load TFJS model at ' + url);
    const m = await tf.loadLayersModel(url);
    appendLog('✔ TFJS model loaded');
    return m;
  } catch(err){
    appendLog('No TFJS model found (fallback to Tesseract).');
    return null;
  }
}

runBtn.onclick = async () => {
  if(!loadedImage) { alert('画像を選んでください'); return; }
  if(!cvReady) { alert('OpenCVがまだ初期化されていません。少し待ってください。'); return; }

  runBtn.disabled = true;
  statusEl.textContent = '処理中...';
  appendLog('--- Start pipeline ---');

  // try load custom model (GitHub-hosted path)
  const model = await loadTFModelIfPresent();

  // prepare working canvas scaled down for speed (keep aspect)
  const maxW = 1000;
  const img = new Image();
  img.src = URL.createObjectURL(loadedImage);
  await new Promise(r=>img.onload = r);
  const scale = Math.min(1, maxW / img.naturalWidth);
  const cw = Math.round(img.naturalWidth * scale);
  const ch = Math.round(img.naturalHeight * scale);
  const c = document.createElement('canvas');
  c.width = cw; c.height = ch;
  const ctx = c.getContext('2d');
  ctx.drawImage(img, 0, 0, cw, ch);

  // read into OpenCV
  let src = cv.imread(c);
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  // adaptive threshold is robust
  let blur = new cv.Mat();
  cv.GaussianBlur(gray, blur, new cv.Size(3,3), 0);
  let bin = new cv.Mat();
  cv.adaptiveThreshold(blur, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 25, 10);
  // morphological close
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
  cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel);

  // find big board
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  appendLog('Contours: ' + contours.size());
  let boardRect=null; let maxArea=0;
  for(let i=0;i<contours.size();i++){
    let r = cv.boundingRect(contours.get(i));
    const a = r.width*r.height;
    if(a>maxArea){ maxArea=a; boardRect=r; }
  }
  if(!boardRect) { appendLog('Board not found - abort'); runBtn.disabled=false; return; }
  appendLog('Board area: ' + JSON.stringify(boardRect));

  // define top & left hint regions (padding small)
  const pad = 6;
  const topRegion = {x:0,y:0,width:cw,height:Math.max(1, boardRect.y - pad)};
  const leftRegion = {x:0, y: Math.max(0, boardRect.y - pad), width: Math.max(1, boardRect.x - pad), height: Math.min(c.height - boardRect.y + pad, cw)};

  appendLog('Top region: ' + JSON.stringify(topRegion));
  appendLog('Left region: ' + JSON.stringify(leftRegion));

  // extract boxes helper
  function extractBoxes(regionMat, offX=0, offY=0){
    let vc = new cv.MatVector(); let vh = new cv.Mat();
    cv.findContours(regionMat, vc, vh, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    let boxes=[];
    for(let i=0;i<vc.size();i++){
      let r = cv.boundingRect(vc.get(i));
      if(r.width<6 || r.height<6) continue;
      if(r.width > regionMat.cols*0.9 || r.height > regionMat.rows*0.9) continue;
      boxes.push({x:r.x+offX, y:r.y+offY, w:r.width, h:r.height});
    }
    vc.delete(); vh.delete();
    return boxes;
  }

  const topMat = bin.roi(new cv.Rect(topRegion.x, topRegion.y, topRegion.width, topRegion.height));
  const leftMat = bin.roi(new cv.Rect(leftRegion.x, leftRegion.y, leftRegion.width, leftRegion.height));
  let topBoxes = extractBoxes(topMat, topRegion.x, topRegion.y);
  let leftBoxes = extractBoxes(leftMat, leftRegion.x, leftRegion.y);
  appendLog(`Raw boxes: top=${topBoxes.length}, left=${leftBoxes.length}`);

  // merge/normalize/split
  function normalizeSplit(boxes, horiz=true){
    boxes.sort((a,b)=> horiz ? a.x-b.x : a.y-b.y);
    // merge near duplicates
    const merged=[];
    const dth = 8;
    boxes.forEach(b=>{
      let found = merged.find(m => Math.abs(m.x-b.x)<=dth && Math.abs(m.y-b.y)<=dth);
      if(found){
        const x1 = Math.min(found.x,b.x), y1 = Math.min(found.y,b.y);
        const x2 = Math.max(found.x+found.w, b.x+b.w), y2 = Math.max(found.y+found.h, b.y+b.h);
        found.x = x1; found.y=y1; found.w = x2-x1; found.h = y2-y1;
      } else merged.push(Object.assign({}, b));
    });
    // split wide ones
    const final=[];
    merged.forEach(m=>{
      if(m.w > m.h*1.6){
        const n = Math.max(2, Math.round(m.w / m.h));
        const wunit = Math.floor(m.w / n);
        for(let k=0;k<n;k++) final.push({x:m.x+k*wunit, y:m.y, w:wunit, h:m.h});
      } else final.push(m);
    });
    final.sort((a,b)=> horiz ? a.x-b.x : a.y-b.y);
    return final;
  }

  const topFinal = normalizeSplit(topBoxes, true);
  const leftFinal = normalizeSplit(leftBoxes, false);
  appendLog(`Postprocessed: top=${topFinal.length}, left=${leftFinal.length}`);

  // helper: create 28x28 canvas (white bg, black digit)
  function make28Canvas(rect){
    const s=28;
    const tmp = document.createElement('canvas'); tmp.width=s; tmp.height=s;
    const tctx = tmp.getContext('2d');
    // pull data from bin mat
    const roi = bin.roi(new cv.Rect(rect.x, rect.y, rect.w, rect.h));
    const maxSide = Math.max(rect.w, rect.h);
    let padded = cv.Mat.zeros(maxSide, maxSide, roi.type());
    roi.copyTo(padded.rowRange(0,rect.h).colRange(0,rect.w));
    const dst = new cv.Mat();
    cv.resize(padded, dst, new cv.Size(s,s), 0,0,cv.INTER_AREA);
    // create ImageData: invert back to black-on-white for OCR
    const id = new ImageData(s,s);
    for(let r=0;r<s;r++){
      for(let c=0;c<s;c++){
        const v = dst.ucharPtr(r,c)[0];
        const idx = (r*s+c)*4;
        id.data[idx] = id.data[idx+1] = id.data[idx+2] = 255 - v; // invert
        id.data[idx+3] = 255;
      }
    }
    tctx.putImageData(id, 0,0);
    roi.delete(); padded.delete(); dst.delete();
    return tmp;
  }

  // OCR function: prefer TFJS model if present, else Tesseract
  async function ocrCanvas(c28){
    if(model){
      // get tensor, model expects [1,28,28,1] normalized 0-1
      const imgdata = c28.getContext('2d').getImageData(0,0,28,28).data;
      const arr = new Float32Array(28*28);
      for(let i=0;i<28*28;i++) arr[i] = (imgdata[i*4]/255.0);
      const t = tf.tensor(arr, [1,28,28,1]);
      const pred = model.predict(t);
      const d = pred.argMax(1).dataSync()[0];
      t.dispose(); pred.dispose();
      return String(d);
    } else {
      // Tesseract fallback
      const res = await Tesseract.recognize(c28, 'eng', { logger: m => {} , tessedit_char_whitelist:'0123456789'});
      return (res && res.data && res.data.text) ? res.data.text.replace(/[^0-9]/g,'').trim() : '?';
    }
  }

  // run OCR for arrays
  async function runOnRects(rects, containerEl){
    containerEl.innerHTML = '';
    const out = [];
    for(let i=0;i<rects.length;i++){
      const r = rects[i];
      const c28 = make28Canvas(r);
      const txt = await ocrCanvas(c28);
      const div = document.createElement('div'); div.className='thumb';
      div.appendChild(c28);
      const label = document.createElement('div'); label.textContent = txt; div.appendChild(label);
      containerEl.appendChild(div);
      appendLog(`Rect(${r.x},${r.y},${r.w},${r.h}) -> ${txt}`);
      out.push({rect:r,text:txt});
    }
    return out;
  }

  statusEl.textContent = 'OCR: top...';
  const topRes = await runOnRects(topFinal, topHintsEl);
  statusEl.textContent = 'OCR: left...';
  const leftRes = await runOnRects(leftFinal, leftHintsEl);

  appendLog('--- End pipeline ---');
  statusEl.textContent = '完了';
  runBtn.disabled = false;

  // cleanup
  src.delete(); gray.delete(); blur.delete(); bin.delete(); kernel.delete();
  contours.delete(); hierarchy.delete(); topMat.delete(); leftMat.delete();
};
</script>
</body>
</html>
