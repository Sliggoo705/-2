<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Digit Extract High Precision</title>
<style>
  body { font-family: sans-serif; }
  #digits canvas {
    margin: 4px;
    border: 1px solid #ccc;
  }
</style>
</head>

<body>
<h2>Digit Extract High Precision (A版)</h2>

<input type="file" id="fileInput" accept="image/*"><br><br>

<div id="log"></div>
<div id="digits"></div>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="cvLoaded()"></script>

<script>
// ログ表示用
function log(text) {
    document.getElementById("log").innerHTML += text + "<br>";
}

// OpenCVロード完了フラグ
let cvReady = false;

function cvLoaded() {
    cv['onRuntimeInitialized'] = () => {
        cvReady = true;
        log("✔ OpenCV.js ready!");
    };
}

// 画像アップロードイベント
document.getElementById("fileInput").addEventListener("change", async (e) => {
    if (!cvReady) {
        alert("OpenCV is not ready yet. Wait 1–2 seconds.");
        return;
    }

    const file = e.target.files[0];
    const img = new Image();
    img.src = URL.createObjectURL(file);
    img.onload = () => extractDigits(img);
});

// ----------------------------
// 改良版：数字抽出関数
// ----------------------------
function extractDigits(img) {
    log("=== Start extraction ===");

    let src = cv.imread(img);
    log("Read image: " + src.cols + " x " + src.rows);

    // グレースケール
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    // 二値化（OTSU）
    let bin = new cv.Mat();
    cv.threshold(gray, bin, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

    // ノイズ除去（小さい点を消す）
    let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
    cv.morphologyEx(bin, bin, cv.MORPH_OPEN, kernel);

    // 輪郭抽出
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // --- 盤面領域を推定して除外 ---
    let boardRect = null;
    let maxArea = 0;
    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let rect = cv.boundingRect(cnt);
        let area = rect.width * rect.height;
        if (area > maxArea) {
            maxArea = area;
            boardRect = rect;
        }
    }
    log("Board area (excluded): " + JSON.stringify(boardRect));

    // 数字抽出
    const container = document.getElementById("digits");
    container.innerHTML = "";
    let digitCount = 0;

    for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let rect = cv.boundingRect(cnt);
        let x = rect.x, y = rect.y, w = rect.width, h = rect.height;

        // 盤面領域は除外
        if (boardRect &&
            x > boardRect.x - 5 &&
            x + w < boardRect.x + boardRect.width + 5 &&
            y > boardRect.y - 5 &&
            y + h < boardRect.y + boardRect.height + 5) 
        {
            continue;
        }

        // サイズフィルタ（数字サイズのみ）
        if (w > 40 && h > 40) continue; // 大きすぎる → 盤面の一部
        if (w < 8 || h < 8) continue;   // 小さすぎる → ノイズ

        log(`✔ Digit ${digitCount+1}: x=${x}, y=${y}, w=${w}, h=${h}`);

        // 切り抜き & 表示
        let roi = bin.roi(new cv.Rect(x, y, w, h));
        let canvas = document.createElement("canvas");
        cv.imshow(canvas, roi);
        container.appendChild(canvas);

        roi.delete();
        digitCount++;
    }

    log("Total digits extracted: " + digitCount);

    // 後処理
    src.delete(); gray.delete(); bin.delete();
    contours.delete(); hierarchy.delete(); kernel.delete();

    log("=== End extraction ===");
}
</script>

</body>
</html>
