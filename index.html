<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Picross OCR — Auto grouped (tuned)</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <style>
    body{font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;margin:16px}
    #preview,#debugCanvas{max-width:95vw;border:1px solid #ccc;margin-top:10px;display:block}
    #out{white-space:pre-wrap;background:#fbfbfd;padding:10px;border-radius:8px;margin-top:12px}
    .small{font-size:13px;color:#444}
    #note{font-size:13px;color:#666;margin-top:8px}
  </style>
</head>
<body>
  <h2>Picross OCR — Auto grouped hints (tuned)</h2>
  <p class="small">Upload a puzzle screenshot (with grid). The script auto-detects the grid, reads only hint areas, groups numbers per hint, and outputs JSON {rows, cols}.</p>

  <input type="file" id="imgInput" accept="image/*">
  <img id="preview" crossorigin="anonymous" />
  <canvas id="debugCanvas" style="display:none"></canvas>
  <pre id="out">結果はここに表示されます（JSON）</pre>
  <div id="note">注: このバージョンは画像を直接調整して最小の手動操作で動くようチューニング済みです。</div>

<script>
/* 完全自動バージョン（ユーザー操作なし）
   - 前提: 多くのスマホスクショピクロスに合うよう調整済み（画像提供版にチューニング）
   - 出力: {"rows": [...], "cols": [...] }
*/

const imgInput = document.getElementById('imgInput');
const preview = document.getElementById('preview');
const debugCanvas = document.getElementById('debugCanvas');
const out = document.getElementById('out');

let lastImage = null;

// create canvas
function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
function cropCanvas(src,x,y,w,h){ const c=makeCanvas(w,h); c.getContext('2d').drawImage(src,x,y,w,h,0,0,w,h); return c; }

// preprocess tuned for your image: scale & binarize defaults tuned
function preprocess(img, scale=2.5, thresh=160){
  const cw = Math.round(img.width*scale), ch = Math.round(img.height*scale);
  const c = makeCanvas(cw,ch);
  const ctx = c.getContext('2d');
  ctx.drawImage(img,0,0,cw,ch);
  const im = ctx.getImageData(0,0,cw,ch);
  const d = im.data;
  for(let i=0;i<d.length;i+=4){
    const g = (d[i]+d[i+1]+d[i+2]) / 3;
    const v = g > thresh ? 255 : 0;
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(im,0,0);
  return c;
}

// projection counts
function projectionCounts(canvas){
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const data = ctx.getImageData(0,0,w,h).data;
  const row = new Uint32Array(h), col = new Uint32Array(w);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx=(y*w+x)*4;
      if(data[idx] < 128){ row[y]++; col[x]++; }
    }
  }
  return {row,col,w,h};
}

// detect grid bounds using strong peaks (tuned thresholds)
function detectGridBounds(bin){
  const {row,col,w,h} = projectionCounts(bin);
  const rowMax = Math.max(...row), colMax = Math.max(...col);
  const rowThresh = Math.max(1, Math.floor(rowMax * 0.6));
  const colThresh = Math.max(1, Math.floor(colMax * 0.6));
  const rowLines = []; for(let y=0;y<h;y++) if(row[y] >= rowThresh) rowLines.push(y);
  const colLines = []; for(let x=0;x<w;x++) if(col[x] >= colThresh) colLines.push(x);
  if(rowLines.length < 2 || colLines.length < 2) return null;
  const top = rowLines[0], bottom = rowLines[rowLines.length-1];
  const left = colLines[0], right = colLines[colLines.length-1];
  // median gap = estimated cell size
  const rowGaps=[]; for(let i=1;i<rowLines.length;i++) rowGaps.push(rowLines[i]-rowLines[i-1]);
  const colGaps=[]; for(let i=1;i<colLines.length;i++) colGaps.push(colLines[i]-colLines[i-1]);
  const cellH = median(rowGaps), cellW = median(colGaps);
  return {top,bottom,left,right,rowLines,colLines,cellH,cellW,w,h};
}
function median(a){ if(!a||a.length===0) return 0; const s=a.slice().sort((p,q)=>p-q); const m=Math.floor(s.length/2); return s.length%2? s[m] : Math.round((s[m-1]+s[m])/2); }

// find 1D clusters (continuous non-zero segments)
function findClusters1D(proj, minSize=2){
  const clusters=[]; let inC=false, start=0;
  for(let i=0;i<proj.length;i++){
    if(proj[i] > 0 && !inC){ inC=true; start=i; }
    else if(proj[i] === 0 && inC){ inC=false; clusters.push([start, i-1]); }
  }
  if(inC) clusters.push([start, proj.length-1]);
  return clusters.filter(c => (c[1]-c[0]+1) >= minSize);
}

// OCR of a small canvas; tries rotation fallback automatically
async function ocrSmallCanvas(c){
  // scale a little
  const s = makeCanvas(Math.max(8, Math.round(c.width*1.6)), Math.max(8, Math.round(c.height*1.6)));
  s.getContext('2d').drawImage(c,0,0,s.width,s.height);
  try{
    const res = await Tesseract.recognize(s, 'eng', { tessedit_char_whitelist:'0123456789', tessedit_pageseg_mode:'7' });
    let txt = (res?.data?.text || '').replace(/[^\d]/g,'').trim();
    if(!txt){
      // rotate 90deg and try
      const r = makeCanvas(s.height, s.width);
      const ctx = r.getContext('2d'); ctx.translate(r.width/2, r.height/2); ctx.rotate(Math.PI/2);
      ctx.drawImage(s, -s.width/2, -s.height/2);
      const res2 = await Tesseract.recognize(r, 'eng', { tessedit_char_whitelist:'0123456789', tessedit_pageseg_mode:'7' });
      txt = (res2?.data?.text || '').replace(/[^\d]/g,'').trim();
    }
    return txt;
  }catch(e){
    console.error('OCR error', e);
    return '';
  }
}

// cluster-slicing for left area (rows): returns array per hint-line: [canvas,canvas,...] left->right
function sliceLeftIntoRowDigitCanvases(leftCanvas){
  const ctx = leftCanvas.getContext('2d'); const w=leftCanvas.width, h=leftCanvas.height;
  const data = ctx.getImageData(0,0,w,h).data;
  const rowProj = new Uint32Array(h);
  for(let y=0;y<h;y++){ let s=0; for(let x=0;x<w;x++){ if(data[(y*w+x)*4] < 128) s++; } rowProj[y]=s; }
  const rowBands = findClusters1D(rowProj, 2);
  const rows = [];
  for(const [sy,ey] of rowBands){
    const band = cropCanvas(leftCanvas, 0, sy, w, ey - sy + 1);
    const bctx = band.getContext('2d'); const bw = band.width, bh = band.height;
    // vertical projection within band
    const colProj = new Uint32Array(bw);
    for(let x=0;x<bw;x++){ let s=0; for(let y=0;y<bh;y++){ if(bctx.getImageData(x,y,1,1).data[0] < 128) s++; } colProj[x]=s; }
    const colClusters = findClusters1D(colProj, 1);
    const digitCanvases = [];
    for(const [sx,ex] of colClusters){
      const pad = Math.max(1, Math.round(bw*0.02));
      const x0 = Math.max(0, sx - pad), w0 = Math.min(bw - x0, ex - sx + 1 + pad*2);
      digitCanvases.push(cropCanvas(band, x0, 0, w0, bh));
    }
    rows.push(digitCanvases);
  }
  return rows;
}

// slice top (columns): returns array per column: [canvas,canvas,...] top->bottom
function sliceTopIntoColDigitCanvases(topCanvas){
  const ctx = topCanvas.getContext('2d'); const w=topCanvas.width, h=topCanvas.height;
  const data = ctx.getImageData(0,0,w,h).data;
  const colProj = new Uint32Array(w);
  for(let x=0;x<w;x++){ let s=0; for(let y=0;y<h;y++){ if(data[(y*w+x)*4] < 128) s++; } colProj[x]=s; }
  const colBands = findClusters1D(colProj, 2);
  const cols = [];
  for(const [sx,ex] of colBands){
    const band = cropCanvas(topCanvas, sx, 0, ex - sx + 1, h);
    const bctx = band.getContext('2d'); const bw = band.width, bh = band.height;
    const rowProj = new Uint32Array(bh);
    for(let y=0;y<bh;y++){ let s=0; for(let x=0;x<bw;x++){ if(bctx.getImageData(x,y,1,1).data[0] < 128) s++; } rowProj[y]=s; }
    const rowClusters = findClusters1D(rowProj, 1);
    const digitCanvases = [];
    for(const [sy,ey] of rowClusters){
      const pad = Math.max(1, Math.round(bh*0.02));
      const y0 = Math.max(0, sy - pad), h0 = Math.min(bh - y0, ey - sy + 1 + pad*2);
      digitCanvases.push(cropCanvas(band, 0, y0, bw, h0));
    }
    cols.push(digitCanvases);
  }
  return cols;
}

// split OCR digit-string into plausible hint numbers (each between 1..maxVal) using minimal segments heuristic
function splitDigitsHeuristic(s, maxVal){
  if(!s || s.length===0) return [];
  // remove leading zeros
  s = s.replace(/^0+/, '');
  if(s.length===0) return [];
  const L = s.length;
  // try all splits by partitioning between digits
  const best = {parts:null, count:999, scores:[]};
  // partition positions: choose cuts among L-1 possible
  const totalMasks = 1 << (L-1);
  for(let mask=0; mask<totalMasks; mask++){
    const parts=[]; let cur = s[0];
    for(let i=0;i<L-1;i++){
      if( (mask>>i)&1 ){
        parts.push(cur); cur = s[i+1];
      } else {
        cur += s[i+1];
      }
    }
    parts.push(cur);
    // convert to ints and validate
    const nums = parts.map(p=>parseInt(p,10));
    if(nums.some(n=>isNaN(n) || n <= 0)) continue;
    // all nums must be <= maxVal (if not, this partition invalid)
    if(nums.some(n => n > maxVal)) continue;
    // choose partition with minimal number of parts (prefer fewer parts => larger grouped numbers)
    if(nums.length < best.count){
      best.count = nums.length; best.parts = nums;
    }
  }
  // if no valid partition found (e.g. "51" & maxVal=15 -> [5,1] accepted; but if none), fallback:
  if(!best.parts){
    // best-effort: split into single digits but drop zeros
    return s.split('').map(ch=>parseInt(ch,10)).filter(n=>n>0);
  }
  // return best.parts as numbers
  return best.parts.map(p=>parseInt(p,10));
}

// OCR canvases -> grouped numeric arrays (rows)
async function ocrRowCanvasesToNumbers(rowCanvases, maxVal){
  const out = [];
  for(const digitCanvases of rowCanvases){
    const nums = [];
    for(const c of digitCanvases){
      const txt = await ocrSmallCanvas(c);
      if(!txt) continue;
      const grouped = splitDigitsHeuristic(txt, maxVal);
      grouped.forEach(n=> nums.push(n));
    }
    out.push(nums);
  }
  return out;
}
async function ocrColCanvasesToNumbers(colCanvases, maxVal){
  const out = [];
  for(const digitCanvases of colCanvases){
    const nums = [];
    for(const c of digitCanvases){
      const txt = await ocrSmallCanvas(c);
      if(!txt) continue;
      const grouped = splitDigitsHeuristic(txt, maxVal);
      grouped.forEach(n=> nums.push(n));
    }
    out.push(nums);
  }
  return out;
}

// erase grid lines so OCR won't confuse them (white-over peaks)
function eraseGridLines(canvas){
  const ctx = canvas.getContext('2d');
  const {row,col,w,h} = projectionCounts(canvas);
  const rowMax = Math.max(...row), colMax = Math.max(...col);
  const rowThresh = Math.max(1, Math.floor(rowMax*0.6));
  const colThresh = Math.max(1, Math.floor(colMax*0.6));
  const lineHalf = 1;
  for(let y=0;y<h;y++) if(row[y] >= rowThresh) ctx.fillStyle='#ffffff', ctx.fillRect(0, y-lineHalf, w, lineHalf*2+1);
  for(let x=0;x<w;x++) if(col[x] >= colThresh) ctx.fillStyle='#ffffff', ctx.fillRect(x-lineHalf, 0, lineHalf*2+1, h);
}

// ----------------- Main -----------------
imgInput.addEventListener('change', (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  preview.src = URL.createObjectURL(f);
  preview.onload = ()=> { lastImage = preview; out.textContent = '画像読み込み完了。自動処理を開始します…'; runFullProcess(); };
});

async function runFullProcess(){
  try{
    out.textContent = '前処理（自動）…';
    const bin = preprocess(lastImage, 2.5, 160);

    // debugCanvas show (hidden by default)
    debugCanvas.width = bin.width; debugCanvas.height = bin.height;
    debugCanvas.getContext('2d').drawImage(bin,0,0);

    out.textContent = 'グリッド検出…';
    const grid = detectGridBounds(bin);
    if(!grid){ out.textContent = 'グリッドを検出できませんでした。別の画像を試してください。'; return; }

    out.textContent = 'グリッド線を除去（OCRの妨げを減らす）…';
    eraseGridLines(bin);

    // extract top and left hint areas
    const topArea = cropCanvas(bin, grid.left, 0, grid.right - grid.left, grid.top);
    const leftArea = cropCanvas(bin, 0, grid.top, grid.left, grid.bottom - grid.top);

    // slice into digit canvases
    out.textContent = '行（左）領域を切り分け…';
    const rowCanvases = sliceLeftIntoRowDigitCanvases(leftArea);
    out.textContent = `行ヒント行候補: ${rowCanvases.length} 行 (クラスタ毎にOCR)`;

    out.textContent = '列（上）領域を切り分け…';
    const colCanvases = sliceTopIntoColDigitCanvases(topArea);
    out.textContent = `列ヒント列候補: ${colCanvases.length} 列 (クラスタ毎にOCR)`;

    // OCR -> numeric groups (maxVal inferred from grid width (cells) if possible)
    const maxVal = grid ? Math.max(grid.cellH, grid.cellW) || 15 : 15; // conservative fallback
    out.textContent = 'OCR 実行中…少し待ってください';
    const rowNums = await ocrRowCanvasesToNumbers(rowCanvases, 15); // max hint value = 15
    const colNums = await ocrColCanvasesToNumbers(colCanvases, 15);

    // filter empty lines and produce final arrays
    const rows = rowNums.map(r => r.filter(n=>!isNaN(n))).filter(r=>r.length>0);
    const cols = colNums.map(c => c.filter(n=>!isNaN(n))).filter(c=>c.length>0);

    const result = { rows, cols };
    out.textContent = JSON.stringify(result, null, 2);
    console.log('parsed hints', result);
  }catch(err){
    console.error(err);
    out.textContent = '処理中にエラーが発生しました: ' + err;
  }
}
</script>
</body>
</html>
