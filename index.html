<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Picross High-Precision OCR & Solver</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<style>
body{font-family:Arial,sans-serif;margin:16px;background:#fafafa;}
canvas{border:1px solid #ccc;margin-top:10px;display:block;}
#preview,#solution{max-width:95vw;}
pre{background:#fff;padding:10px;border-radius:6px;margin-top:10px;overflow-x:auto;}
.small{font-size:13px;color:#555;}
</style>
</head>
<body>
<h2>Picross High-Precision OCR & Solver</h2>
<p class="small">スクショをアップロードすると、高精度でOCR→ヒント修正→自動解答を描画します。</p>
<input type="file" id="imgInput" accept="image/*">
<canvas id="preview"></canvas>
<canvas id="solution"></canvas>
<pre id="jsonOut">JSON結果はここに表示されます。</pre>

<script>
const imgInput = document.getElementById('imgInput');
const preview = document.getElementById('preview');
const solutionCanvas = document.getElementById('solution');
const jsonOut = document.getElementById('jsonOut');
let uploadedImg = null;

// --- Canvas helper ---
function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
function cropCanvas(src,x,y,w,h){ const c=makeCanvas(w,h); c.getContext('2d').drawImage(src,x,y,w,h,0,0,w,h); return c; }

// --- Preprocess image: 二値化＋ノイズ除去＋グリッド線除去 ---
function preprocessImage(img,scale=1.5,thresh=160){
  const cw=Math.round(img.width*scale), ch=Math.round(img.height*scale);
  const c=makeCanvas(cw,ch);
  const ctx=c.getContext('2d');
  ctx.drawImage(img,0,0,cw,ch);
  const im=ctx.getImageData(0,0,cw,ch); const d=im.data;
  // 白黒化
  for(let i=0;i<d.length;i+=4){
    const g=(d[i]+d[i+1]+d[i+2])/3;
    d[i]=d[i+1]=d[i+2]=g>thresh?255:0;
  }
  ctx.putImageData(im,0,0);
  // TODO: グリッド線除去のアルゴリズムを追加可能
  return c;
}

// --- OCR a single small cluster ---
async function ocrSingle(c){
  const s=makeCanvas(Math.max(8,c.width*1.6),Math.max(8,c.height*1.6));
  s.getContext('2d').drawImage(c,0,0,s.width,s.height);
  try{
    let res=await Tesseract.recognize(s,'eng',{tessedit_char_whitelist:'0123456789', tessedit_pageseg_mode:7});
    return (res?.data?.text||'').replace(/[^\d]/g,'').trim();
  }catch(e){ console.error(e); return ''; }
}

// --- Split digits heuristically ---
function splitDigitsHeuristic(s,maxVal){
  if(!s) return [];
  s=s.replace(/^0+/,''); if(!s) return [];
  const L=s.length; let best={parts:null,count:999};
  for(let mask=0;mask<1<<(L-1);mask++){
    const parts=[]; let cur=s[0];
    for(let i=0;i<L-1;i++){ if((mask>>i)&1){ parts.push(cur); cur=s[i+1]; }else cur+=s[i+1]; }
    parts.push(cur);
    const nums=parts.map(p=>parseInt(p,10)); if(nums.some(n=>isNaN(n)||n<=0||n>maxVal)) continue;
    if(nums.length<best.count){ best.count=nums.length; best.parts=nums; }
  }
  if(!best.parts) return s.split('').map(ch=>parseInt(ch,10)).filter(n=>n>0);
  return best.parts.map(p=>parseInt(p,10));
}

// --- Fix hints exceeding cell counts ---
function fixHints(hints,maxCells){
  return hints.map(line=>{
    let newLine=[];
    for(let n of line){
      if(n<=0) continue;
      while(n>maxCells){ newLine.push(maxCells); n-=maxCells; }
      if(n>0) newLine.push(n);
    }
    while(newLine.reduce((a,b)=>a+b,0)>maxCells){
      const idx=newLine.indexOf(Math.max(...newLine));
      newLine[idx]-=1;
    }
    return newLine;
  });
}

// --- Simple solver (only definite cells) ---
function solvePicross(rows,cols){
  const H=rows.length,W=cols.length;
  const grid=Array.from({length:H},()=>Array(W).fill(null));
  for(let r=0;r<H;r++){
    const sum=rows[r].reduce((a,b)=>a+b,0)+rows[r].length-1;
    if(sum===W){
      let idx=0;
      for(const v of rows[r]){
        for(let i=0;i<v;i++) grid[r][idx++]=1;
        if(idx<W) idx++;
      }
    }
  }
  for(let c=0;c<W;c++){
    const sum=cols[c].reduce((a,b)=>a+b,0)+cols[c].length-1;
    if(sum===H){
      let idx=0;
      for(const v of cols[c]){
        for(let i=0;i<v;i++) grid[idx++][c]=1;
        if(idx<H) idx++;
      }
    }
  }
  return grid;
}

// --- Draw solution ---
function renderSolution(grid){
  const H=grid.length,W=grid[0].length;
  solutionCanvas.width=W*20; solutionCanvas.height=H*20;
  const ctx=solutionCanvas.getContext('2d');
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,solutionCanvas.width,solutionCanvas.height);
  ctx.strokeStyle='#888';
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      ctx.strokeRect(x*20,y*20,20,20);
      if(grid[y][x]===1){ ctx.fillStyle='#000'; ctx.fillRect(x*20+1,y*20+1,18,18); }
    }
  }
}

// --- Main ---
imgInput.addEventListener('change',ev=>{
  const f=ev.target.files[0]; if(!f) return;
  uploadedImg=new Image();
  uploadedImg.onload=async()=>{
    const bin=preprocessImage(uploadedImg,1.5,160);
    preview.width=bin.width; preview.height=bin.height;
    preview.getContext('2d').drawImage(bin,0,0);

    const H=15; // 行数仮定
    const W=15; // 列数仮定
    const rowHintArea=cropCanvas(bin,0,0,Math.floor(bin.width*0.2),bin.height);
    const colHintArea=cropCanvas(bin,0,0,bin.width,Math.floor(bin.height*0.2));

    // --- ここからクラスタ分割 OCR ---
    // 仮：行ヒントをH等分
    const rowClusters=[];
    for(let i=0;i<H;i++){
      const y=Math.floor(i*rowHintArea.height/H);
      const h=Math.floor(rowHintArea.height/H);
      rowClusters.push(cropCanvas(rowHintArea,0,y,rowHintArea.width,h));
    }
    const rowOCRs=await Promise.all(rowClusters.map(c=>ocrSingle(c)));
    const rows_fixed=rowOCRs.map(t=>splitDigitsHeuristic(t,W)).map(r=>fixHints([r],W)[0]);

    // 仮：列ヒントをW等分
    const colClusters=[];
    for(let i=0;i<W;i++){
      const x=Math.floor(i*colHintArea.width/W);
      const w=Math.floor(colHintArea.width/W);
      colClusters.push(cropCanvas(colHintArea,x,0,w,colHintArea.height));
    }
    const colOCRs=await Promise.all(colClusters.map(c=>ocrSingle(c)));
    const cols_fixed=colOCRs.map(t=>splitDigitsHeuristic(t,H)).map(c=>fixHints([c],H)[0]);

    jsonOut.textContent=JSON.stringify({rows:rows_fixed,cols:cols_fixed});

    const solution=solvePicross(rows_fixed,cols_fixed);
    renderSolution(solution);
  };
  uploadedImg.src=URL.createObjectURL(f);
});
</script>
</body>
</html>
