<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Digit Extract + 28x28 Normalize (Lightweight)</title>
<style>
  body { font-family: sans-serif; }
  #digits canvas {
    margin: 4px;
    border: 1px solid #ccc;
  }
</style>
</head>

<body>
<h2>Digit Extract + 28x28 Normalize (Lightweight)</h2>
<input type="file" id="fileInput" accept="image/*"><br><br>
<div id="log"></div>
<div id="digits"></div>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
document.addEventListener("DOMContentLoaded", async () => {
    const fileInput = document.getElementById("fileInput");
    const logDiv = document.getElementById("log");
    const digitsDiv = document.getElementById("digits");

    function log(text){ logDiv.innerHTML += text + "<br>"; console.log(text); }

    // OpenCVロード待機
    await new Promise(resolve => {
        cv['onRuntimeInitialized'] = () => { log("✔ OpenCV.js ready!"); resolve(); };
    });

    fileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = () => processImage(img);
    });

    function processImage(img) {
        log("=== Start extraction ===");

        // 入力画像を軽量化
        let scale = Math.min(600 / img.width, 1.0); // 最大幅600px
        let w = Math.round(img.width * scale);
        let h = Math.round(img.height * scale);

        let canvas = document.createElement("canvas");
        canvas.width = w; canvas.height = h;
        let ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h);

        let src = cv.imread(canvas);

        // グレースケール + 二値化
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        let bin = new cv.Mat();
        cv.threshold(gray, bin, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

        // 輪郭検出
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // 最大矩形を盤面と判断して除外
        let maxArea = 0, boardRect = null;
        for (let i = 0; i < contours.size(); i++) {
            let r = cv.boundingRect(contours.get(i));
            let area = r.width * r.height;
            if (area > maxArea) { maxArea = area; boardRect = r; }
        }
        log("Board area excluded: " + JSON.stringify(boardRect));

        // 数字候補抽出
        let candidates = [];
        for (let i = 0; i < contours.size(); i++) {
            let r = cv.boundingRect(contours.get(i));
            if (boardRect &&
                r.x > boardRect.x - 5 &&
                r.x + r.width < boardRect.x + boardRect.width + 5 &&
                r.y > boardRect.y - 5 &&
                r.y + r.height < boardRect.y + boardRect.height + 5) continue;
            if (r.width < 8 || r.height < 8 || r.width > 100 || r.height > 60) continue;
            candidates.push(r);
        }

        log("Total digit candidates: " + candidates.length);

        // 28x28正規化して表示
        digitsDiv.innerHTML = "";
        candidates.forEach((r, idx) => {
            let roi = bin.roi(new cv.Rect(r.x, r.y, r.width, r.height));
            let size = Math.max(r.width, r.height);
            let padded = cv.Mat.zeros(size, size, roi.type());
            roi.copyTo(padded.rowRange(0, r.height).colRange(0, r.width));

            let square = new cv.Mat();
            cv.resize(padded, square, new cv.Size(28,28), 0,0, cv.INTER_AREA);

            let outCanvas = document.createElement("canvas");
            outCanvas.width = 28; outCanvas.height = 28;
            cv.imshow(outCanvas, square);
            digitsDiv.appendChild(outCanvas);

            log(`Digit ${idx+1}: x=${r.x}, y=${r.y}, w=${r.width}, h=${r.height}`);

            roi.delete(); padded.delete(); square.delete();
        });

        src.delete(); gray.delete(); bin.delete(); contours.delete(); hierarchy.delete();

        log("=== End extraction ===");
    }
});
</script>
</body>
</html>
