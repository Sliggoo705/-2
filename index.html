<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Digit Extract + 28x28 Normalize (Final Completed)</title>
<style>
  body { font-family: sans-serif; }
  #digits canvas {
    margin: 4px;
    border: 1px solid #ccc;
  }
</style>
</head>

<body>
<h2>Digit Extract + 28x28 Normalize (Final Completed)</h2>

<input type="file" id="fileInput" accept="image/*"><br><br>

<div id="log"></div>
<div id="digits"></div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="cvLoaded()"></script>

<script>
function log(text) {
    document.getElementById("log").innerHTML += text + "<br>";
}

let cvReady = false;
function cvLoaded() {
    cv['onRuntimeInitialized'] = () => {
        cvReady = true;
        log("✔ OpenCV.js ready!");
    };
}

document.getElementById("fileInput").addEventListener("change", (e) => {
    if (!cvReady) { alert("OpenCV is not ready yet."); return; }
    const file = e.target.files[0];
    const img = new Image();
    img.src = URL.createObjectURL(file);
    img.onload = () => extractDigits(img);
});

// ----------------------------
// 横ヒント隣接統合 + 横長矩形分割 + 28x28正規化
// ----------------------------
function extractDigits(img) {
    log("=== Start extraction ===");

    let src = cv.imread(img);
    log("Read image: " + src.cols + " x " + src.rows);

    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    let bin = new cv.Mat();
    cv.threshold(gray, bin, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

    let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
    cv.morphologyEx(bin, bin, cv.MORPH_OPEN, kernel);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // 盤面の除外
    let boardRect = null;
    let maxArea = 0;
    for (let i = 0; i < contours.size(); i++) {
        let rect = cv.boundingRect(contours.get(i));
        let area = rect.width * rect.height;
        if (area > maxArea) { maxArea = area; boardRect = rect; }
    }
    log("Board area (excluded): " + JSON.stringify(boardRect));

    // 数字候補
    let candidates = [];
    for (let i = 0; i < contours.size(); i++) {
        let rect = cv.boundingRect(contours.get(i));
        if (boardRect &&
            rect.x > boardRect.x - 5 &&
            rect.x + rect.width < boardRect.x + boardRect.width + 5 &&
            rect.y > boardRect.y - 5 &&
            rect.y + rect.height < boardRect.y + boardRect.height + 5) continue;
        if (rect.width < 8 || rect.height < 8 || rect.width > 80 || rect.height > 60) continue;
        candidates.push(Object.assign({}, rect));
    }

    // 中心距離 + 矩形重なり
    function center(rect) { return {cx: rect.x + rect.width/2, cy: rect.y + rect.height/2}; }
    function intersect(r1,r2){
        return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x ||
                 r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
    }

    // 横ヒントラインに分ける
    const yLineThreshold = 15;
    let lines = [];
    candidates.sort((a,b)=>a.y-b.y);
    candidates.forEach(r=>{
        let added=false;
        for(let line of lines){
            if(Math.abs(line[0].y - r.y)<=yLineThreshold){ line.push(r); added=true; break; }
        }
        if(!added) lines.push([r]);
    });

    let merged = [];

    lines.forEach(line=>{
        // 中心x順にソート
        line.sort((a,b)=> (a.x + a.width/2) - (b.x + b.width/2));

        // 隣接統合ループ
        let temp = line.map(r=>Object.assign({}, r));
        let changed = true;
        while(changed){
            changed=false;
            let newTemp = [];
            let used = Array(temp.length).fill(false);
            for(let i=0;i<temp.length;i++){
                if(used[i]) continue;
                let m = Object.assign({}, temp[i]);
                for(let j=i+1;j<temp.length;j++){
                    if(used[j]) continue;
                    let r = temp[j];
                    let c1=center(m), c2=center(r);
                    if(intersect(m,r) || (Math.abs(c1.cx-c2.cx)<=25 && Math.abs(c1.cy-c2.cy)<=15)){
                        let x1 = Math.min(m.x,r.x), y1=Math.min(m.y,r.y);
                        let x2 = Math.max(m.x+m.width, r.x+r.width);
                        let y2 = Math.max(m.y+m.height, r.y+r.height);
                        m.x=x1; m.y=y1; m.width=x2-x1; m.height=y2-y1;
                        used[j]=true; changed=true;
                    }
                }
                newTemp.push(m);
            }
            temp=newTemp;
        }

        // 横長矩形を分割
        temp.forEach(r=>{
            if(r.width/r.height>2){
                let n = Math.round(r.width/r.height);
                let wUnit = Math.floor(r.width/n);
                for(let k=0;k<n;k++){
                    merged.push({x:r.x+k*wUnit, y:r.y, width:wUnit, height:r.height});
                }
            }else merged.push(r);
        });
    });

    log("Total merged digits: " + merged.length);

    const container = document.getElementById("digits");
    container.innerHTML = "";

    // 28x28正規化
    merged.forEach((rect, idx)=>{
        let roi = bin.roi(new cv.Rect(rect.x, rect.y, rect.width, rect.height));
        let size = Math.max(rect.width, rect.height);
        let padded = cv.Mat.zeros(size, size, roi.type());
        roi.copyTo(padded.rowRange(0,rect.height).colRange(0,rect.width));

        let square = new cv.Mat();
        cv.resize(padded, square, new cv.Size(28,28),0,0,cv.INTER_AREA);

        let canvas = document.createElement("canvas");
        canvas.width=28; canvas.height=28;
        cv.imshow(canvas,square);
        container.appendChild(canvas);

        log(`Digit ${idx+1}: x=${rect.x}, y=${rect.y}, w=${rect.width}, h=${rect.height}`);

        roi.delete(); padded.delete(); square.delete();
    });

    src.delete(); gray.delete(); bin.delete(); kernel.delete();
    contours.delete(); hierarchy.delete();

    log("=== End extraction ===");
}
</script>

</body>
</html>
